# 第一篇 概论

## 第一章 计算机系统概论

$$
计算机系统\begin{cases}
硬件：& 计算机实体部分，由看得见摸得着的各种电子元器件，各类光、电、机设备的实物组成\\
软件：& 由人们事先编制的具有各类特殊功能的程序组成
\end{cases}
$$

$$
计算机软件\begin{cases}
系统软件：& 又称系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行。包括：标准程序库，语言处理程序，操作系统，服务系统，数据库管理系统，网络软件等\\
应用软件：& 又称应用程序，是根据用户任务需要所编制的各种程序
\end{cases}
$$

### 1.1 计算机系统简介

#### 1.1.2 计算机系统的层次结构

现代计算机解题过程如下：

> 由用户用高级语言编写程序（称为源程序），**然后将它和数据一起送入计算机内**，再由计算机将其翻译成机器能识别的机器语言程序（称为目标程序），机器自动运行该机器语言程序，并将结果算出。

![计算机的解题过程](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/计算机的解题过程.png)

直接执行机器语言的机器称为实际机器$M_1$

>  符号式的程序设计语言，即汇编语言。

把具有翻译功能的汇编程序的计算机看做机器$M_2$，并不是一台实际机器，称为虚拟机

![多级层次结构的计算机系统](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/多级层次结构的计算机系统.png)

![计算机系统层次结构](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/计算机系统层次结构.png)

#### 1.1.3 计算机组成和计算机体系结构

$$
\begin{cases}
计算机体系结构：& 能够被程序员见到的计算机系统的属性，即概念性的结构与功能特性\\
计算机组成：& 如何实现计算机体系结构所体现的属性，包含很多对于程序员来说是透明的硬件细节
\end{cases}
$$

​	一台机器是否具备乘法指令的功能，这是一个结构问题，可是，实现成发指令采用什么样的方式，则是一个组成问题。



### 1.2 冯·诺依曼计算机的特点

（原版）

- 计算机由运算器、存储器、控制器、输入设备和输出设备五大部件组成。
- 指令和数据以同等地位存放于存储器中，并可按地址寻访。
- 指令和数据均用二进制数表示。
- 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置
- 指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序。
- 机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成。

（总结）

- 指令、数据用二进制表示
- 采用存储程序的工作方式
- 计算机由五大部件组成

#### 1.2.2 计算机的硬件框图

典型的冯诺依曼计算机是以运算器为中心的，现代的计算机已转化为以存储器为中心。

![冯诺依曼计算机结构](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/冯诺依曼计算机结构.png)

图中各部件功能如下：

- 运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内。
- 存储器用来存放数据和程序。
- 控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果。
- 输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。
- 输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印输出’显示器输出等。

运算器 + 控制器 = 中央处理器（CPU）

输入设备与输出设备简称为I/O设备，又可称为外部设备

CPU + 主存储器 = 主机

现代计算机有三大部分组成：CPU、I/O设备及主存储器

![现代计算机的组成框图](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/现代计算机的组成框图.png)

算术逻辑单元（ALU）用来完成算术逻辑运算。

控制单元（CU）用来解释存储器中的指令。并发出各种操作命令来执行指令。

ALU和CU是CPU的核心部件。

#### 1.2.3 计算机的工作步骤

##### 1. 上机前的准备

1. 建立数学模型
2. 确定计算方法
3. 编制解题程序

##### 2. 计算机的工作过程

![细化的计算机组成框图](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/细化的计算机组成框图.png)

1. 主存储器

   包括存储体M、各种逻辑部件及控制电路等

   存储体由许多存储单元组成，每个存储单元又包含若干个存储元件（或称存储基元，存储元），每个存储元件能寄存一位二进制代码“0”或“1”。

   MAR是存储器地址寄存器，用来存放欲访问的存储单元的地址，其位数对应存储单元的个数。

   MDR是存储器数据寄存器，用来存放从存储体某单元取出的代码或者准备往某存储单元存入的代码，其位数与存储字长相等

2. 运算器

   运算器最少包括3个寄存器和一个算术逻辑单元（ALU）

   其中ACC为累加器，MQ为乘商寄存器，X为操作数寄存器

   //表示两个寄存器串接

3. 控制器

   完成一条指令操作需要取指、分析和执行3个阶段

   控制器由程序计数器（PC）、指令寄存器（IR）以及控制单元（CU）组成

   PC用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路，且具有自动加1的功能，即可自动形成下一条指令的地址。

   IR用来存放当前的指令，IR的内容来自主存的MDR

   CU用来分析当前指令所需完成的操作，并发出各种微操作命令序列，用以控制所有被控对象

4. I/O

### 1.3 计算机硬件的主要技术指标

#### 机器字长

#### 存储容量

​	存储容量 = 存储单元个数  × 存储字长

#### 运算速度

![全书各章节之间的关系](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/全书各章节之间的关系.png)

![第一单元练习题](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/第一单元练习题.png)

# 第三篇 中央处理器

## 第六章 计算机的运算方法

计算机中参与运算的数有两大类：无符号数和有符号数

### 6.1 无符号数和有符号数

#### 6.1.1 无符号数

计算机中的数均存放在寄存器中，寄存器的位数称为机器字长

#### 6.1.2 有符号数

用“0”表示“+”， 用“1”表示”-“

##### 1. 机器数与真值

把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。

##### 2. 原码表示法

原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值。

整数的符号位与数值位之间用逗号隔开；小数的符号位与数值位之间用小数点隔开。

整数原码的定义为：
$$
[x]_原\begin{cases}
0, x& 2^n>x≥0\\
2^n-x& 0≥x>-2^n
\end{cases} 

其中，x为真值， n为整数的位数
$$
小数原码的定义为：
$$
[x]_原\begin{cases}
x& 1>x≥0\\
1-x& 0≥x>-1
\end{cases} 

其中，x为真值
$$
[+0]<sub>原</sub>不等于[-0]<sub>原</sub>

##### 3. 补码表示法

**(1). 补数的概念**

- 一个负数可以用它的正补数来代替，而这个正补数可以用模加上负数本身求得。
- 一个正数和一个负数互为补数时，他们的绝对值之和即为模数。
- 正数的补数即为该正数本身

**(2). 补码的定义**

整数补码定义为：
$$
[x]_补\begin{cases}
0, x& 2^n>x≥0\\
2^{n+1}+x& 0>x≥-2^n&(mod2^{n+1})
\end{cases} 

其中，x为真值， n为整数的位数
$$
小数补码定义为：
$$
[x]_补\begin{cases}
x& 1>x≥0\\
2+x& 0>x≥-1&(mod2^{n+1})
\end{cases} 

其中，x为真值
$$
补码中，0只有一种表现形式。

##### 4. 反码表示法

反码通常用来作为原码求补码或者由补码求原码的中间过渡。

整数反码定义如下：
$$
[x]_反\begin{cases}
0, x& 2^n>x≥0\\
(2^{n+1}-1)+x& 0≥x>-2^n&(mod(2^{n+1}-1))
\end{cases} 

其中，x为真值， n为整数的位数
$$
小数反码的定义为：
$$
[x]_反\begin{cases}
x& 1>x≥0\\
(2-2^{-n})+x& 0≥x>-1&(mod(2-2^{-n}))
\end{cases} 

其中，x为真值， n为小数的位数
$$
反码中，零也有两种表示形式。

三种机器数的特点归纳总结如下：

- 三种机器数的最高位均为符号位。符号与数值部分之间可用“.“（对于小数）或”，“（对于整数）隔开。
- 当真值为正时，原码、补码和反码的表示形式均相同，即符号位用0表示，数值部分与真值相同。
- 当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用1表示，而数值部分有这样的关系，即补码是原码的“求反加1”，反码是原码的“每位求反”。

![对应真值范围](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/对应真值范围.png)

由于“零”在补码中只有一种表示形式，故补码比原码和反码可以多表示一个负数。

![证明题1](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/证明题1.png)

[y]<sub>补</sub>连同符号位在内每位取反，末尾加1，即可得[-y]<sub>补</sub>

##### 5. 移码表示法

移码的定义：
$$
[x]_移 = 2^n + x (2^n > x ≥ -2^n)  

其中，x为真值，n为整数的位数
$$
移码中表示“零”是唯一的。

![真值、补码和移码对照表](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/真值、补码和移码对照表.png)

### 6.2 数的定点表示和浮点表示

#### 6.2.1 定点表示

小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。

#### 6.2.2 浮点表示

$$
N = S × r^j
$$

- S：尾数，可正可负
- j：阶码：可正可负
- r：基数：或基值

#### 6.2.3 定点数和浮点数的比较

1. 当浮点机和定点机中数的位数相同时，浮点数的表示范围比定点数大得多
2. 当浮点数为规格化数时，其相对精度远比定点数高

#### 6.2.5 IEEE 754标准

![实数198.125的几种不同表示](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/实数198.125的几种不同表示.png)

### 6.3 定点运算

#### 6.3.1 移位运算

![不同码制机器数算数移位后的空位填补规则](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/不同码制机器数算数移位后的空位填补规则.png)

有符号数的以为称为算术移位，无符号数的移位称为逻辑移位。

#### 6.2.3 加法与减法运算

##### 1. 补码加减运算的基本公式

- 整数：$[A]_补 + [B]_补 = [ A + B ]_补 (mod 2^{n+1})$
  - $ [ A - B ]_补= [A]_补 + [-B]_补 (mod 2^{n+1})$

- 小数：$[A]_补 + [B]_补 = [ A + B ]_补 (mod 2)$
  - $ [ A - B ]_补= [A]_补 + [-B]_补 (mod 2)$

##### 2. 溢出判断

1. 用一位符号位判断溢出
2. 用两位符号位判断溢出

- 变形补码：两位符号位的补码，以4为模

$$
[x]_补'=\begin{cases}
x& 1>x≥0\\
4+x& 0>x≥-1(mod4)
\end{cases}
$$

- 变形补码判断溢出的原则是：当2位符号位不同时，表示溢出，否则，无溢出。
- 不论是否发生溢出，高位（第1位）符号位永远代表真正的符号。

#### 6.3.3 乘法运算

过程归纳如下：

- 乘法运算可用移位和加法来实现，两个4位数相乘，总共需要进行4次加法运算和4次移位。
- 由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，由次低位作新的末位，空出最高位放部分积的最低位
- 每次做加法时，被乘数仅仅与原部分积的高位相加，其低位被移至乘数所空出的最高位置

##### 原码一位乘

以小数为例：
$$
设 \\
[x]_原 = x_0.x_1x_2···x_n\\
[y]_原 = y_0.y_1y_2···y_n\\
则 \\
[x]_原·[y]_原 = x_0\bigoplus y_0·(0.x_1x_2···x_n)(0.y_1y_2···y_n)\\
式中，0.x_1x_2···x_n为x的绝对值，记作x^*;\\
0.y_1y_2···y_n为y的绝对值，记作y^*.
$$

- 乘积的符号位由两原码符号位异或运算结果决定
- 乘积的数值部分由两数绝对值相乘

##### 原码两位乘

原码乘	符号位和数值位部分分开运算

两位乘	每次用乘数的2位判断原部分积是否加和如何加被乘数

| 乘数y<sub>n-1</sub>y<sub>n</sub> |                新的部分积                 |
| :------------------------------: | :---------------------------------------: |
|               0 0                | 新部分积等于原部分积加0倍被乘数后右移两位 |
|               0 1                | 新部分积等于原部分积加1倍被乘数后右移两位 |
|               1 0                | 新部分积等于原部分积加2倍被乘数后右移两位 |
|               1 1                | 新部分积等于原部分积加3倍被乘数后右移两位 |

| 乘数判断位y<sub>n-1</sub>y<sub>n</sub> | 标志位C<sub>j</sub> |                  操作内容                  |
| :------------------------------------: | :-----------------: | :----------------------------------------: |
|                  0 0                   |          0          |    z→2位，y*→2位，C<sub>j</sub>保持“0”     |
|                  0 1                   |          0          | z + x\*→2位，y*→2位，C<sub>j</sub>保持“0”  |
|                  1 0                   |          0          | z + 2x\*→2位，y*→2位，C<sub>j</sub>保持“0” |
|                  1 1                   |          0          | z - x\*→2位，y*→2位，C<sub>j</sub>保持“1”  |
|                  0 0                   |          1          | z + x\*→2位，y*→2位，C<sub>j</sub>保持“0”  |
|                  0 1                   |          1          | z + 2x\*→2位，y*→2位，C<sub>j</sub>保持“0” |
|                  1 0                   |          1          | z - x\*→2位，y*→2位，C<sub>j</sub>保持“1”  |
|                  1 1                   |          1          |    z→2位，y*→2位，C<sub>j</sub>保持“1”     |

- n为偶数，填两个零；n为奇数，填一个零。
- n为偶数，$\frac{n}{2}$次移位，最多$\frac{n}{2}+1$次加法；n为奇数，$\frac{n}{2}+1$次移位，最多$\frac{n}{2}+1$次移位，最后一次移一位

##### 补码一位乘

$$
设被乘数 [x]_补 = x_0.x_1x_2...x_n\\
乘数 [y]_补 = y_0.y_1y_2...y_n
$$

1) 被乘数x符号任意，乘数y符号为正

- 同原码乘，但加和移位按补码规则运算，乘积的符号自然形成

$$
[x]_补 = x_0.x_1x_2...x_n = 2+x=2^{n+1}+x\\
[y]_补 = 0.y_1y_2...y_n = y\\
[x]_补·[y]_补 = [x]_补·y = (2^{n+1}+x)·y = 2^{n+1}·y + xy\\
[x·y]_补 = [x]_补·[y]_补 = [x]_补·y
$$



2) 被乘数x符号任意，乘数y符号为负

- 乘数$[y]_补$，去掉符号位，同上y符号为正，最后加$[-x]_补$，校正

$$
[x·y]_补 = [x]_补(0.y_1y_2...y_n)+[-x]_补
$$

##### Booth算法（被乘数，乘数任意）

$$
设[X]_补 = x_0.x_1x_2...x_n\\
[y]_补 = y_0.y_1y_2...y_n\\
[x·y]_补\\
= [x]_补(0.y_1...y_n)-[x]_补·y_0\\
= [x]_补(y_12^{-1}+y_22^{-2}+...+y_n2^{-n})-[x]_补·y_0\\
= [x]_补(-y_0+y_12^{-1}+y_22^{-2}+...+y_n2^{-n})\\
= [x]_补[-y_0+(y_1-y_12^{-1})+(y_22^{-1}-y_22^{-2})+...+(y_n2^{-(n-1)}-y_n2^{-n})]\\
= [x]_补[(y_1-y_0)+(y_2-y_1)2^{-1}+...+(y_n-y_{n-1})2^{-(n-1)}+(0-y_n)2^{-n})]\\
= [x]_补[(y_1-y_0)+(y_2-y_1)2^{-1}+...+(y_{n+1}-y_n)2^{-n}]
$$

| $y_i y_{i+1}$ | $y_{i+1}-y_i$ |      操作      |
| :-----------: | :-----------: | :------------: |
|      0 0      |       0       |      → 1       |
|      0 1      |       1       | $+[x]_补$ → 1  |
|      1 0      |      -1       | $+[-x]_补$ → 1 |
|      1 1      |       0       |      → 1       |

 

### 6.4 浮点数四则运算

$$
x = S_x·r^{j_x}
$$

#### 6.4.1 浮点加减运算

1. 对阶，使两数的小数点位置对齐
2. 尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）
3. 规格化，将增加有效数字的位数，提高运算精度，必须将求和（差）之后的尾数规格化
4. 舍入，为提高精度，要考虑尾数右移时丢失的数值位
5. 溢出判断，即判断结果是否溢出

##### 1. 对阶

(1). 求阶差
$$
Δj = j_x - j_y =\begin{cases}
=0 & j_x=j_y\\
>0 & j_x>j_y & y向x看齐\\
<0 & j_x<j_y & x向y看齐
\end{cases}\\
向大的阶码看齐
$$
(2). 对阶

##### 2. 尾数求和

##### 3. 规格化

(1). 规格化数的定义
$$
r = 2\qquad\frac{1}{2}≤|S|<1
$$
(2). 规格化数的判断

| S>0  | 规格化形式 | S<0  | 规格化形式 |
| :--: | :--------: | :--: | :--------: |
| 真值 |  0.1×...×  | 真值 | -0.1×...×  |
| 原码 |  0.1×...×  | 原码 |  1.1×...×  |
| 补码 |  0.1×...×  | 补码 |  1.0×...×  |
| 反码 |  0.1×...×  | 反码 |  1.0×...×  |

原码：不论正数、负数，第一位为1

补码：符号位和第1数位不同

(3). 左规

尾数←1，阶码减1，直到数符和第一数位不同为止

(4). 右规

当尾数溢出（>1)时，需右规

尾数→1，阶码加1

(5). 舍入

在对阶和右规过程中，可能出现尾数末位丢失引起误差，需考虑舍入

- 0舍1如法
- 恒置“1”法

#### 浮点数乘除运算

$$
x = S_x·2^{j_x}\qquad y=S_y·2^{j_y}
$$

##### 1. 乘法

$$
x·y = (S_x·S_y)×2^{j_x+j_y}
$$



##### 2. 除法

$$
\frac{x}{y} = \frac{S_x}{S_y}×2^{j_x-j_y}
$$

##### 3.步骤

(1). 补码采用补码定点加（乘法）减（除法）运算

(2). 尾数乘除同定点运算

(3). 规格化

##### 4. 运算部件

$$
阶码运算部件，尾数运算部件
$$

### 6.5 算术逻辑单元

ALU电路是既能完成算术运算又能完成逻辑运算的部件

如何用硬件实现算术逻辑运算部件ALU？

- 构造一位二进制加法单元；
- 用n位全加器（连同进位信号传送逻辑），构成一个n位并行加法器；
- 以加法器为核心，通过输入选择逻辑扩展为具有多重算术、逻辑功能的ALU。

#### 1. 构造一位二进制加法单元

用抑或逻辑实现半加，再用两次半加实现一次全加。

- $Σ_i = A_i \bigoplus B_i \bigoplus C_{i-1} $
  - $C_i = A_iB_i + (A_i \bigoplus B_i) C_{i-1}$

#### 2. 并行加法器与进位逻辑结构

> 并行加法器的逻辑结构包含两部分：全加器单元与进位链

(1). 进位信号的基本逻辑结构

假定第i-1位为低位，则第i位产生的进位信号逻辑为：
$$
C_i = A_iB_i + (A_i \bigoplus B_i) C_{i-1}\\
或C_i = A_iB_i + (A_i + B_i) C_{i-1}
$$
可将上述逻辑写为通式：
$$
C_i = G_i + P_iC_{i-1}
$$
式中$G_i$称为第i位进位产生函数，$P_i$称为进位传递函数

(2). 串行进位

串行进位进位信号逻辑式：
$$
C_1 = G_1 + P_1C_0\\
C_2 = G_2 + P_2C_1\\
C_3 = G_3 + P_3C_2\\
C_4 = G_4 + P_4C_3\\
......
$$

- 串行进位方式是指：逐级形成各位进位，每一级进位直接依赖于前一级进位。

##### 2. 串行进位链

>进位链		传送进位的电路
>
>串行进位链	进位串行传送

以4位全加器为例，每一位的进位表达式为：

$$
C_0 = d_0 + t_0C_{-1}=\overline{\overline{d_0}·\overline{t_0C_{-1}}}\\
C_1 = d_1 + t_1C_0\\
C_2 = d_2 + t_2C_1\\
C_3 = d_3 + t_3C_2
$$

##### 3. 并行进位（先行进位、跳跃进位）

# 第七章 指令系统

## 7.1 机器指令

### 一、指令的一般格式

操作码字段+地址码字段

#### 1. 操作码	反应机器做什么操作

(1). 长度固定

​	用于指令字长较长的情况，RISC

​	如 IBM 370 操作码 8 位

(2). 长度可变

​	操作码分散在指令字的不同字段中

(3). 扩展操作码技术

​	操作码的位数随着地址数的减少而增加

<div style="text-align: center">
    <span style="border:2px solid;">OP</span>
    <span style="border:2px solid;">A<sub>1</sub></span>
    <span style="border:2px solid;">A<sub>2</sub></span>
    <span style="border:2px solid;">A<sub>3</sub></span>
</div>

4位操作码	15条三地址指令

| 0000  | $A_1$ | $A_2$ | $A_3$ |
| :---: | :---: | :---: | :---: |
| 0001  | $A_1$ | $A_2$ | $A_3$ |
| $...$ | $...$ | $...$ | $...$ |
| 1110  | $A_1$ | $A_2$ | $A_3$ |

8位操作码	15条二地址指令

| 1111  | 0000  | $A_2$ | $A_3$ |
| :---: | :---: | :---: | :---: |
| 1111  | 0001  | $A_2$ | $A_3$ |
| $...$ | $...$ | $...$ | $...$ |
| 1111  | 1110  | $A_2$ | $A_3$ |

12位操作码	15条一地址指令

| 1111  | 1111  | 0000  | $A_3$ |
| :---: | :---: | :---: | :---: |
| 1111  | 1111  | 0001  | $A_3$ |
| $...$ | $...$ | $...$ | $...$ |
| 1111  | 1111  | 1110  | $A_3$ |

16位操作码	16条零地址指令

| 1111  | 1111  | 1111  | 0000  |
| :---: | :---: | :---: | :---: |
| 1111  | 1111  | 1111  | 0001  |
| $...$ | $...$ | $...$ | $...$ |
| 1111  | 1111  | 1111  | 1111  |

#### 2. 地址码

(1). 四地址

<div style="text-align: center">
    <span style="border:2px solid;">OP</span>
    <span style="border:2px solid;">A<sub>1</sub></span>
    <span style="border:2px solid;">A<sub>2</sub></span>
    <span style="border:2px solid;">A<sub>3</sub></span>
     <span style="border:2px solid;">A<sub>4</sub></span>
</div>

> $A_1$：第一操作数地址
>
> $A_2$：第二操作数地址
>
> $A_3$：结果的地址
>
> $A_4$：下一条指令地址

$$
(A_1)OP(A_2)→A_3
$$

设指令字长为32位，操作码固定为8位

4次访存

寻址范围 $2^6 = 64$ 

(2). 三地址

<div style="text-align: center">
    <span style="border:2px solid;">OP</span>
    <span style="border:2px solid;">A<sub>1</sub></span>
    <span style="border:2px solid;">A<sub>2</sub></span>
    <span style="border:2px solid;">A<sub>3</sub></span>
</div>

$$
(A_1)OP(A_2)→A_3
$$

4次访存

寻址范围 $2^8 = 256 $

(3). 二地址

<div style="text-align: center">
    <span style="border:2px solid;">OP</span>
    <span style="border:2px solid;">A<sub>1</sub></span>
    <span style="border:2px solid;">A<sub>2</sub></span>
</div>

$$
(A_1)OP(A_2) → A_1\\
或\\
(A_1)OP(A_2) → A_2
$$

4次访存

寻址范围 $2^{12} = 4K$

若结果存于ACC	3次访存（若ACC代替$A_1$或$A_2$）

(4). 一地址

<div style="text-align: center">
    <span style="border:2px solid;">OP</span>
    <span style="border:2px solid;">A<sub>1</sub></span>
</div>

$$
(ACC)OP(A_1)→ACC
$$

2次访存

寻址范围 $2^{24} = 16M$

(5). 零地址

无地址码

### 二、指令字长

$$
指令字长取决于\begin{cases}
操作码的长度\\
操作数地址的长度\\
操作数地址的个数
\end{cases}
$$

#### 1. 指令字长固定

指令字长 = 存储字长

#### 2. 指令字长可变

按字节倍数变化

#### 3. 小结

- 当用一些硬件资源代替指令字中的地址码字段后
  - 可扩大指令的寻址范围
  - 可缩短指令字长
  - 可减少访存次数

- 当指令的地址字段为寄存器时
  - 三地址	$OP, R_1,R_2,R_3$
  - 二地址	$OP, R_1,R_2$
  - 一地址	$OP, R_1$

## 7.2 操作数类型和操作种类

### 一、操作数类型

> 地址	无符号整数
>
> 数字	定点数、浮点数、十进制数
>
> 字符	ASCII	
>
> 逻辑数	逻辑运算

### 二、数据在存储器中的存放方式

### 三、操作类型

#### 1. 数据传送

> 源		寄存器	寄存器	存储器	存储器
>
> 目的	寄存器	存储器·	寄存器	存储器·
>
> 例如	MOVE	STORE	LOAD	MOVE
>
> ​				MOVE	MOVE
>
> ​				PUSH	POP

置“1”，清“0”

#### 2. 算术逻辑操作

加、减、乘、除、增1、减1、求补、浮点运算、十进制运算

与、或、非、抑或、位操作、位测试、位清除、位求反

#### 3. 移位操作

算术移位		逻辑移位

循环移位（带进位和不带进位）

#### 4. 转移

(1). 无条件转移 JMP

(2). 条件转移

​	结果为零转		(Z = 1)	 JZ

​	结果溢出转		(O = 1) 	JO

​	结果有进位转		(C = 1) 	JC

​	跳过一条指令		SKP

(3). 调用和返回

(4). 陷阱（Trap）与陷阱指令

#### 5. 输入输出

​	入		端口地址			CPU的寄存器

​	出		CPU的寄存器		端口地址

## 7.3 寻址方式

确定本条指令的操作数地址

下一条预执行指令的指令地址

### 一、 指令寻址

​	顺序	(PC) + 1 → PC

​	跳跃	由转移指令指出 

### 二、数据寻址

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">1</td>
        <td style="border: 1px solid;width: max-content;text-align: center">1</td>
        <td style="border: 1px solid;width: max-content;text-align: center">1</td>
    </tr>
</table>


> 形式地址		指令字中的地址
>
> 有效地址		操作数的真实地址
>
> 约定		指令字长 = 存储字长 = 机器字长

#### 1. 立即寻址（寻址特征#）

​	形式地址A就是操作数

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center">#</td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>

- 立即数：补码表示、可正可负
- 指令执行阶段不访存
- A的位数限制了立即数的范围

#### 2. 直接寻址（最常用的）

​	EA = A	有效地址由形式地址直接给出

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">LDA</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>

- 执行阶段访问一次存储器
- A的位数决定了该指令操作数的寻址范围
- 操作数的地址不易修改（必须改为A）

#### 3. 隐含寻址

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">ADD</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>

​	操作数的地址隐含在操作码中 

#### 4. 间接寻址（最常考）

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>

​	EA = (A)		有效地址由形式地址间接提供

- 执行指令阶段2次访存
- 可扩大寻址范围
- 便于编制程序

#### 5. 寄存器寻址

​	EA = $R_i$		有效地址即为寄存器编号

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">R<sub>i</sub></td>
    </tr>
</table>

- 执行阶段不访存，只访问寄存器，执行速度快
- 寄存器个数有限，可缩短指令字长

#### 6. 寄存器间接寻址

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">R<sub>i</sub></td>
    </tr>
</table>

​	EA = ($R_i$)		有效地址在寄存器当中

- 有效地址在寄存器中，操作数在存储器中，执行阶段访存
- 便于编制循环程序

#### 7. 基址寻址

(1). 采用专用寄存器作基址寄存器

​	EA = (BR) + A		BR为基址寄存器

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>
- 可扩大寻址范围
- 便与程序搬家（程序重定位）
- BR内容由操作系统或管理程序确定
- 在程序的执行过程中BR内容不变，形式地址A可变

(2). 采用通用寄存器作基址寄存器

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">R<sub>0</sub></td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>

- 由用户指定哪个通用寄存器作为基址寄存器
- 基址寄存器内容由操作系统确定
- 在程序的执行过程中$R_0$内容不变，形式地址A可变

#### 8.变址寻址

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>
​	EA = (IX) + A		IX为变址寄存器（专用），通用寄存器也可以作为变址寄存器 

- 可扩大寻址范围
- IX的内容由用户给定
- 在程序的执行过程中$IX $内容不变，形式地址A可变
- 便于处理数组问题

#### 9. 相对寻址

<table>
    <tr>
        <td style="border: 1px solid;width: max-content;text-align: center">OP</td>
        <td style="border: 1px solid;width: max-content;text-align: center"></td>
        <td style="border: 1px solid;width: max-content;text-align: center">A</td>
    </tr>
</table>
​	EA = (PC) + A		A是相对于当前指令的位移量（可正可负，补码）

- A的位数决定操作数的寻址范围
- 程序浮动
- 广泛用于转移指令

#### 10. 堆栈寻址

(1). 堆栈的特点
$$
堆栈\begin{cases}
硬堆栈& 多个寄存器\\
软堆栈& 指定的存储空间
\end{cases}\\
先进后出（一个入出口）栈顶地址由SP指出\\
进栈 (SP)-1→SP\\
出栈 (SP)+1→SP
$$
(2). SP的修改与主存编制方法有关

1. 按字编址

   > 进栈	(SP) - 1 → SP
   >
   > 出栈	(SP) + 1 → SP

2. 按字节编址

   >存储字长16位
   >
   >> 进栈	(SP) - 2→ SP
   >>
   >> 出栈	(SP) + 2→ SP
   >
   >存储字长32位
   >
   >> 进栈	(SP) - 4→ SP
   >>
   >> 出栈	(SP) + 4→ SP

## 7.2 指令格式举例

### 一、设计指令格式时应考虑的各种因素

1. 指令系统的兼容性（向上兼容）

2. 其他因素

   > 操作类型		包括指令个数及操作的难易程度
   >
   > 数据类型
   >
   > 指令格式		指令字长、操作码位数
   >
   > ​			寻址方式、是否采用扩展操作码
   >
   > ​			地址码位数、地址个数
   >
   > 寻址方式
   >
   > 寄存器个数

# 第四章 存储器

## 4.1 概述

### 一、存储器分类

#### 1. 按存储介质分类

(1). 半导体存储器（静态、动态）	TTL、MOS			易失

(2). 磁表面存储器					磁头、磁载体

(3). 磁芯存储器					硬磁材料、环装原件

(4). 光盘存储器					激光，磁光材料

#### 2. 按存取方式分类

(1).存取时间与物理地址无关（ 随机访问方式）

- 随机存储器RAM		在程序执行过程中可读可写
- 只读存储器ROM 		在程序的执行过程中只读

(2). 存取时间与物理地址有关（串行访问）

- 顺序存取存储器		磁带
- 直接存取存储器		磁盘

#### 3. 按照在计算机中的作用分类

$$
存储器\begin{cases}
主存储器\begin{cases}
RAM\begin{cases}
静态RAM\\
动态RAM
\end{cases}\\
ROM\begin{cases}
MROM&数据在出厂之前就已经写进去了\\
PROM&一次性写入\\
EPROM&紫外线照射擦除再写入\\
EEPROM&加高压电将信息擦除再写入
\end{cases}
\end{cases}\\
Flash Memory\\
高速缓冲存储器（Cache）&当前一小段时间可能被使用的数据\\

辅助存储器(后备)&磁盘、磁带、光盘
\end{cases}
$$

### 二、存储器的层次结构

#### 1. 存储器三个重要特性的关系（速度、容量、价格/位）

![存储器三个主要特征的关系.png](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/存储器三个主要特征的关系.png)

#### 2. 缓存-主存层次和主存-辅存层次

![缓存-主存层次和主存-辅存层次.png](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/缓存-主存层次和主存-辅存层次.png)

## 4.2 主存储器

### 一、概述

#### 1. 主存的基本组成

#### 2. 主存与CPU的联系

#### 3. 主存中存储单元地址的分配

#### 4. 主存的技术指标

(1). 存储容量		主存	存放二进制代码的总数量

(2). 存储速度

- 存取时间

  - > 存储器的		访问时间
    >
    > 读出时间		写入时间

- 存取周期

  - > 连续两次独立存储器操作
    >
    > （读或写）所需的最小间隔时间
    >
    > 读周期    写周期

(3). 存储器的带宽       位/秒

### 二、半导体存储芯片简介

#### 1. 半导体存储芯片的基本结构

![半导体存储芯片的基本结构.png](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/半导体存储芯片的基本结构.png)

| 地址线（单向） | 数据线（双向） | 芯片容量  |
| :------------: | :------------: | :-------: |
|       10       |       4        | 1K × 4位  |
|       14       |       1        | 16K × 1位 |
|       13       |       8        | 8K × 8位  |

##### 存储芯片片选线的作用

​	用16K × 1位的存储芯片组成64K × 8位的存储器（32个分成四组每组八个排成一列）

 #### 2. 半导体存储芯片的译码驱动方式

![线选法](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/线选法.png)

![重合法](https://gitee.com/ScottDemo/cloudimg/raw/master/专业课/计算机组成原理/重合法.png)

### 三、随机存取存储器（RAM）







































































