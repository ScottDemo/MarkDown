# 第一章 绪论

编译：将`高级语言`翻译成`汇编语言`或`机器语言`的过程 ===\==> 源语言 翻译成 目标语言 的过程

**编译器在语言处理系统中的地位**：

![编译器在语言处理系统中的地位](E:\MarkDown\专业课\编译原理图床\编译器在语言处理系统中的地位.png)

## 编译系统的结构

词法分析 ==> 语法分析 ==> 语义分析

## 词法分析

- 词法分析的主要任务

  从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词换成统一的<span style="color:red">机内表示</span>——词法单元(token)形式

  token：<种别码， 属性值>

|      | 单词类型 |                             种别                             |            种别码            |
| :--: | :------: | :----------------------------------------------------------: | :--------------------------: |
|  1   |  关键字  |                 program、if、else、then、···                 |           一词一码           |
|  2   |  标识符  |             变量名、数组名、记录名、过程名、···              |           多词一码           |
|  3   |   常量   |              整型、浮点型、字符型、布尔型、···               |           一型一码           |
|  5   |  运算符  | 算术（+  -  *  /  ++  --）<br>关系（>  <  ==  !=  >=  <==）<br>逻辑（&  \|  ~  ） | 一词一码<br/>或<br/>一型一码 |
|  5   |  界限符  |                       ;  (  )  =  {  }                       |           一词一码           |

## 语法分析

- 语法分析器从词法分析器输出的token序列中识别出各类短语，并构造语法分析树。

## 语义分析

语义分析的主要任务：

- 收集标识符的属性信息

  - 种属（Kind）
    - 简单变量、复合变量（数组、记录、…）、过程、…

  - 类型（Type）
    - 整形、实型、字符型、布尔型、指针型、…

  - 存储位置、长度

  - 值
  - 作用域
  - 参数和返回值信息

- 语义检查
  - 变量或过程未经声明就使用
  - 变量或过程名重复声明
  - 运算分量类型不匹配
  - 操作符与操作数之间的类型不匹配
    - 数组下标不是整数
    - 对非数组变量使用数组访问操作符
    - 对非过程名使用过程调用操作符
    - 过程调用的参数类型或数目不匹配
    - 函数返回类型有误

## 中间代码生成及编译器后端概述

### 常用的中间表示形式

#### 三地址码

三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数

常用的三地址指令

| 序号 |    指令类型    |          指令形式          |                      四元式表示                      |
| :--: | :------------: | :------------------------: | :--------------------------------------------------: |
|  1   |    赋值指令    |   x = y op z<br>x= op y    |         ( op, y, z, x )<br/>( op, y, _, x )          |
|  2   |    复制指令    |           x = y            |                    ( =, y, _, x )                    |
|  3   |    条件跳转    |    if x relop y goto n     |                  ( relop, x, y, n)                   |
|  4   |   非条件跳转   |           goto n           |                  ( goto, _, _, x )                   |
|  5   |    参数传递    |          param x           |                  ( param, _, _, x )                  |
|  6   |    过程调用    |         call p, n          |                  ( call, p, n, _ )                   |
|  7   |    过程返回    |          return x          |                 ( return, _, _, x )                  |
|  8   |    数组引用    |          x = y[i]          |                   ( =[], y, i, x )                   |
|  9   |    数组赋值    |          x[i] = y          |                   ( []=, y, x, i )                   |
|  10  | 地址及指针操作 | x = &y<br>x =* y<br>*x = y | ( &, y, _, x )<br>( =*, y, _, x )<br>( *=, y, _, x ) |

#### 三地址指令的表示

- 四元式
  - （op, y, z, x)

- 三元式
- 间接三元式

### 编译器的结构

- 目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言。
- 目标代码生成的一个重要任务是为程序中使用的变量合理分配寄存器。
- 代码优化
  - 为改进代码所进行的等价程序变换，使其运行的更快一些、占用空间更少一些，或者二者兼顾。

# 第二章 程序设计语言及其文法

## 2-1 基本概念

- 字母表Σ是一个又穷符号集合
  - 符号：字母、数字、标点符号…
  - 例：
    - 二进制字母表：{0, 1}
    - ASCII字符集
    - Unicode字符集

### 字母表的运算

- 字母表$Σ_1$和$Σ_2$的乘积
  - $Σ_1$$Σ_2$ = { ab | a ∈ $Σ_1$， b ∈ $Σ_2$ }

- 字母表Σ的n次幂
  - $Σ^0 = { ε }$
  - $Σ^n = Σ^{n-1}Σ$, n≥1

- 字母表Σ的正闭包
  - $Σ^+ = Σ∪Σ^2∪Σ^3∪…$

- 字母表Σ的克林闭包
  - $Σ^* = Σ∪Σ^+ = Σ^0∪Σ∪Σ^2∪Σ^3∪…$

### 串

- 设Σ是一个字母表，$\forall x∈Σ^*$，x称为是Σ上的一个串
  - 串是字母表中符号的一个有穷序列

- 串s的长度，通常记作|s|，是指s中符号的个数
- 空串是长度为0的串，用ε表示
  - | ε | = 0

#### 串上的运算——连接

- 空串是连接运算的单位元
- 设x, y, z是三个字符串，如果x = yz，则称y是x的前缀，z是x的后缀

#### 串上的运算——幂



## 2-2 文法的定义

### 文法的形式化定义

$G = ( V_T, V_N, P, S )$

- $V_T$：终结符集合
  - 终结符是文法所定义的语言的基本符号，有时也称为token

- $V_N$：非终结符集合
  - 非终结符是用来表示语法成分的符号，有时也称为“语法变量”
  - 例：$V_N$ = { <句子>, <名词短语>, <动词短语>, <名词>, …}

- $V_T ∩ V_N = ∅$
- $V_T ∪ V_N：文法符号集$

- P：产生式集合
  - 产生式描述了将终结符和非终结符组合成串的方法
    - 产生式的一般形式：α -> β		读作：α定义为β

- S：开始符号
  - S ∈ $V_N$。开始符号表示的是该文法中最大的语法成分。

### 产生式的简写

对一组有相同左部的α产生式	

​		$α->β_1, α->β_2, …, α->β_n$

可以简记为：

​		$α->β_1|β_2|…|β_n$

读作：α定义为$β_1$，或者$β_2$, …, 或者$β_n$。

$β_1，β_2，…, β_3$称为α的候选式。

### 符号约定

- 下述符号是终结符
  - 字母表中排在前面的小写字母，如a、b、c
  - 运算符，如 + 、 * 等
  - 标点符号，如括号、逗号等
  - 数字0、1、… 、9
  - 粗体字符串，如id、if等

- 下述符号是非终结符
  - 字母表中排在前面的大写字母，如A、B、C
  - 字母S、通常表示开始符号
  - 小写、斜体的名字，如<i>expr，stmt</i>等
  - 代表程序构造的大写字母。如E(表达式)、T(项)和F(因子)

- 字母表中排在后面的大写字母（如X、Y、Z）表示文法符号（即终结符或非终结符）
- 字母表中排在后面的小写字母（主要是u、v、…、z）表示终结符号串（包括空串）
- 小写希腊字母，如α、β、γ，表示文法符号串（包括空串）
- 除非特别说明，第一个产生式的左部就是开始符号

|  终结符  a、b、c  | 终结符号串  u、v、…、z |
| :---------------: | :--------------------: |
| 非终结符  A、B、C |                        |
| 文法符号  X、Y、Z |  文法符号串  α、β、γ   |

## 2-3 语言的定义

### 推导和归约

​	给定文法G=($V_T$, $V_N$, $P$, $S$)，如果α->β∈P，那么可以将符号串γαδ中的α替换为β，也就是说，将γαδ重写为γβδ，记作 γαδ => γβδ，此时，称文法中的符号串γαδ直接推导出γβδ。

- 简而言之，就是用产生式的右部替换产生式的左部

### 句型和句子

​	如果S => *α，α∈($V_T∪V_N$)\*，则称α是G的一个句型

- 一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串

### 语言的形式化定义

由文法G的开始符号S推导出的所有句子构成的集合称为文法G生成的语言，记为L(G)，即：
$$
L(G) = {w | S => *w, w ∈V_T^*}
$$

##  文法的分类

### Chomsky文法分类体系

- 0型文法
- 1型文法
- 2型文法
- 3型文法

### 0型文法

$$
α -> β
$$

- 无限制文法/短语结构文法
  - $\forall α -> β ∈ P$，α中至少包含1个非终结符

- 0型语言
  - 由0型文法G生成的语言L(G)


### 1型文法

$$
α -> β
$$

- 上下文有关文法(CSG)
  - $\forall α -> β ∈ P$，|α|≤ |β|
  - 产生式的一般形式：$α_1Αα_2 -> α_1βα_2（β ≠ ε）$
  - CSG中不包含ε产生式
- 1型语言
  - 由1型文法G生成的语言L(G)

### 2型文法

$$
α → β
$$

- 上下文无关文法（CFG）
  - $\forall α → β ∈ P$，α∈$V_N$
  - 产生式的一般形式：$Α→β$
- 2型语言
  - 由2型文法G生成的语言L(G)

### 3型文法

$$
α → β
$$

- 正则文法（RG）
  - 右线性文法：$A → wB 或 A → w$
  - 左线性文法：$A → Bw 或 A → w$
  - 左线性文法和右线性文法都称为正则文法
- 3型语言
  - 由3型文法G生成的语言L(G)

### 四种文法之间的关系

- 逐级限制
  - 0型文法：α中至少包含一个非终结符
  - 1型文法(CSG)：|α|≤ |β|
  - 2型文法(CFG)：α∈$V_N$
  - 3型文法(RG)：$A → wB 或 A → w$  ($A → Bw 或 A → w$)

## CFG的分析树

- 根节点的标号为文法开始符号
- 内部节点表示对一个产生式A→β的应用，该节点的标号是此产生式左部A。该节点的子节点的标号从左到右构成了产生式的右部β
- 叶节点的标号既可以是非终结符，也可以是终结符。从左到右排列叶节点得到的符号串称为是这棵树的产出或边缘

### （句型的）短语

- 给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个短语。
  - 如果子树只有父子两代节点，那么这棵子树的边缘称为该句型的一个直接短语

> 直接短语一定是某产生式的右部
>
> 但产生式的右部不一定是给定句型的直接短语

### 二义性文法

如果一个文法可以为某个句子生成多颗分析树，则称这个文法是二义性的。

> 对于任意一个上下文无关文法，不存在一个算法判定它是无二义性的；但是能给出一组充分条件，满足这组充分条件的文法是无二义性的。
>
> - 满足，肯定无二义性
> - 不满足，也未必就是有二义性的

# 第三章 词法分析

## 正则表达式

- 正则表达式是一种用来描述正则语言的更紧凑的表示方法
- 正则表达式可以由较小的正则表达式按照特定的规则递归的构建。每个正则表达式r定义（表示）一个语言，记为L(r)。这个语言也是根据r的子表达式所表示的语言递归定义的。

### 正则定义

正则定义是具有如下形式的定义序列：
$$
d_1 → r_1\\
d_2 → r_2\\
...\\
d_i → r_i
$$
其中：

- 每个$d_i$都是一个新符号，它们都不在字母表$Σ$中，而且各不相同
- 每个$r_i$是字母表$Σ∪{d_1, d_2, …, d_{i-1}}$上的正则表达式

#### 标识符的正则定义

- digit → 0|1|2|3|4|5|6|7|8|9
- letter → A|B|…|Z|a|b|…|z|_
- id → letter\_(letter\_|digit)*

## 有穷自动机

有穷自动机是对一类处理系统建立的数学模型

这类系统具有一系列离散的输入输出信息和有穷数目的内部状态（状态：概括了对过去输入信息处理的状况） 

系统只需要根据当前所处状态和当前面临的输入信息就可以决定系统的后继行为。每当系统处理了当前的输入后，系统的内部状态也将发生改变。

### FA模型

![有穷自动机组成.png](E:\MarkDown\专业课\编译原理图床\有穷自动机组成.png)

- 输入带：用来存放输入符号串
- 读头：从左向右逐个读取输入符号，不能修改（只读）、不能往返运动
- 有穷控制器：具有有穷个状态数，根据当前的状态和当前输入符号控制转入下一状态

![FA的表示.png](E:\MarkDown\专业课\编译原理图床\FA的表示.png)

### FA定义（接收）的语言

- 给定输入串x，如果存在一个对应于串x的从初始状态到某个中止状态的转换序列，则称串x被该FA接收。
- 由一个有穷自动机M接收的所有串构成的集合称为是该FA定义（或接收）的语言，记为L(M)

### 最长字串匹配原则

当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配

在到达某个终态之后，只要输入带上还有符号，FA就继续前进，以便寻找尽可能长的匹配

## 有穷自动机的分类

- 确定的FA(DFA)
- 非确定的FA(NFA)

### 确定的有穷自动机 (DFA)

$$
M = ( S, Σ, δ, s_θ, F)
$$

- S：有穷状态集
- Σ：输入字母表，即输入符号集合。假设ε不是Σ中的元素
- δ：将S × Σ映射到S的转换函数。$\forall s ∈ S, a ∈ Σ, δ(s, a)$表示从状态s出发，沿着标记为a的边所能到达的状态
- $s_θ$：开始状态（或初始状态），$s_θ∈S$
- F：接收状态（或终止状态）集合，F  $ \subseteq S$

### 非确定的有穷自动机 (NFA)

$$
M = ( S, Σ, δ, s_θ, F)
$$

- S：有穷状态集
- Σ：输入字母表，即输入符号集合。假设ε不是Σ中的元素
- δ：将S × Σ映射到$2^S$的转换函数。$\forall s ∈ S, a ∈ Σ, δ(s, a)$表示从状态s出发，沿着标记为a的边所能到达的状态<span style="color:red">集合</span>
- $s_θ$：开始状态（或初始状态），$s_θ∈S$
- F：接收状态（或终止状态）集合，F  $ \subseteq S$

### DFA和NFA的等价性

- 对于任何NFA N，存在识别同一语言的DFA D
- 对于任何DFA D，存在识别同一语言的NFA  N

### 正则文法 $\Longleftrightarrow$ 正则表达式 $\Longleftrightarrow$ FA

### 带有“ε-边”的NFA

$$
M = ( S, Σ, δ, s_θ, F)
$$

- S：有穷状态集
- Σ：输入字母表，即输入符号集合。假设ε不是Σ中的元素
- δ：将S × (Σ∪{ε})映射到$2^S$的转换函数。$\forall s ∈ S, a ∈ Σ∪\{ε\}, δ(s, a)$表示从状态s出发，沿着标记为a的边所能到达的状态<span style="color:red">集合</span>
- $s_θ$：开始状态（或初始状态），$s_θ∈S$
- F：接收状态（或终止状态）集合，F  $ \subseteq S$

### 带有和不带有“ε-边”的NFA的等价性

### DFA的算法实现

- 输入：以文件结束符eof结尾的字符串x。DFAD的开始状态$s_θ$，接收状态集F，转换函数move
- 输出：如果D接收x，则回答“yes”，否则回答“no”。
- 方法：将下述算法应用于串x。

```c
s = s_θ;
c = nextChar();
while (c!=eof) {
    s = move(s, c);
    c = nextChar();
}
if (s在F中) return "yes";
else return "no";

// 函数nextChar()返回输入串x的下一个符号
// 函数move(s, c)表示从状态s出发，沿着标记为c的边所能到达的状态
```

## 从正则表达式到有穷自动机

RE → NFA → DFA

### 根据RE构造NFA

- ε对应的NFA

- 字母表Σ中符号a对应的NFA
  - $r = r_1r_2$		(直接连)
  - $r = r_1|r_2$&emsp;(一个圈)
  - $r = (r_1)*$（自身一个圈）

## 从NFA到DFA的转换方法

### 子集构造法

- 输入：NFA N
- 输出：接收同样语言的DFA D
- 方法：一开始，ε-closure($s_θ$)是Dstates中的唯一状态，且它未加标记；

```c
while (在Dstates中有一个未标记状态T) {
    给T加上标记;
    for (每个输入符号a) {
        U = ε-closure(move(T, a));
        if (U不在Dstates中)
            将U加入到Dastates中，且不加标记;
        Dtran[T, a] = U;
    }
}
```

|     操作     |                             描述                             |
| :----------: | :----------------------------------------------------------: |
| ε-closure(s) |       能够从NFA的状态s开始只通过ε转换达到的NFA状态集合       |
| ε-closure(T) | 能够从T中的某个NFA状态s开始只通过ε转换到达的NFA状态集合，即$U_{x∈T} ε-closure(s)$ |
|  move(T, a)  |   能够从T中的某个状态s出发通过标号为a的转换到达NFA状态集合   |

### 计算 ε-closure(T)

```c
将T的所有状态压入stack中;
将ε-closure(T)初始化为T;
while (stack非空) {
    将栈顶元素t给弹出栈中;
    for (每个满足如下条件的u：从t出发有一个标号为ε的转换到达状态u)
        if (u不在ε-closure(T)中){
            将u加入到ε-closure(T)中;
            将u压入栈中;
        }
}
```

## 识别单词的DFA

### 识别标识符的DFA

- 标识符的正则定义
  - digit → 0|1|2|3|4|5|6|7|8|9
  - letter → A|B|…|Z|a|b|…|z|_
  - id → letter\_(letter\_|digit)*

# 第四章 语法分析

## 4-1 自顶向下分析概述

### 1. 自顶向下的分析

- 从分析树的顶部（根节点）向底部（叶节点）方向构造分析树
- 可以看成是从文法开始符号S推导出词串w的过程

### 2. 最左推导

- 在最左推导中，总是选择每个句型的最左非终结符进行替换
- 如果S$\Rightarrow^*_{lm}$α，则称α是当前文法的最左句型
- ==归约：将栈顶的一串符号用文法产生式的左部替代，归约可能重复多次==

### 3. 最右推导

- 在最右推导中，总是选择每个句型的最右非终结符进行替换

- 在自底向上的分析中，总是采用最左归约的方式，因此==把最左归约称为规范归约==，而==最右推导相应地称为规范推导==

### 4. 规范归约的概念

1. 有文法G，开始符号为S，如果有$S^* \Rightarrow xβy$，则 xβy是文法G的句型，xy是任意的符号串
2. 如果有$S^* \Rightarrow xAy$，且有$A^+  \Rightarrow β $，则β是句型xβy相对于非终结符A的短语
3. 特别，如果有$ A \Rightarrow β$，则称β是句型xβy相对于A → β的直接宾语
4. 位于一个句型最左边的直接短语称为句柄

$$
\begin{cases}
规范归约：& 使用句柄来定义\\
算符优先分析：& 使用最左素短语来定义\\
LR分析方法：& 使用活前缀来定义
\end{cases}
$$

### 5. 最左推导和最右推导的唯一性

### 6. 规范

​	假定α是文法G的一个句子，如果序列：$α_n, α_{n-1}…, α_0$(=S)满足如下条件，则序列$α_n, α_{n-1}…, α_0$是一个规范

- $α_n = α $是给定的句子
- $α_n = S$是文法的开始符号
- 对任何$i$，0＜$i$≤n，$α_{i-1}$是从$α_i$经把句柄替换为相应文法产生式的左部符号而得到的。

### 7. 规范归约分析中栈的使用

| 一般形式 | 符号栈的内容 | 剩余符号串 |
| :------: | :----------: | :--------: |
|   初态   |      #       |  输入串#   |
|   终态   |      #S      |     #      |

### 8. 优先分析法

1. 简单优先分析法（规范归约）——文法按一定规则规定文法符号的优先关系
2. 算符优先分析法（不规范归约）——规定算符优先关系

### 9. 在一个符号串中，任意两个相邻的终结符号a和b之间，只可能存在三种优先关系：

- a优先级等于b，记作a (等于号中间一个点) b
- a优先级高于b，记作a (大于号中间一个点) b
- a优先级低于b，记作a (小于号中间一个点) b

### 10. 自顶向下的语法分析采用最左推导方式

- 总是选择每个句型的最左非终结符进行替换
- 根据输入流中的下一个终结符，选择最左非终结符的一个候选式

### 11. 自顶向下语法分析的通用形式

- 递归下降分析
  - 由一组过程组成，每个过程对应一个非终结符
  - 由文法开始符号S对应的过程开始，其中地柜调用文法中其他非终结符对应的过程。如果S对应的过程体恰好扫描了整个输入串，则成功完成语法分析。

### 12. 预测分析

- 预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常为1）符号来选择正确的A-产生式
  - 可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为LL(k)文发器
- 预测分析不需要回溯，是一种确定的自顶向下分析方法

### 13. 算符文法

若文法G没有$P → …QR…（P、Q、R）$属于非终结符的产生式，算符优先级关系：

文法G是一个不含ε-的算符文法，对于任何一对终结符a、b

1. a (等于号中间一个点) b，G中有$P → …ab…$或$P → …aQb…$（在同一产生式中）
2. a (小于号中间一个点) b，G中有$P → …aR…$的产生式，且$R^+ \Rightarrow b...$或$R^+ \Rightarrow Qb...$
3. a (大于号中间一个点) b，G中有$P → …Rb…$的产生式，且$R^+ \Rightarrow ...a$或$R^+ \Rightarrow ...aQ$

## 4-2 文法转换

- 含有A→Aa形式产生式的文法称为是直接左递归的

- 如果一个文法中有一个非终结符A使得对某个串a存在一个推导A$\Rightarrow ^+$Aa，那么这个文法就是左递归的
- 经过两步或两步以上推导产生的左递归称为是直接左递归的

### 直接消除左递归

$$
A → Aα | β(α≠ε, β不以A开头)
$$

事实上，这种消除过程就是把左递归转换成了右递归 

消除左递归要付出一些代价——引进了一些非终结符和ε产生式

### 消除间接左递归

将S的定义代入A-产生式

消除A-产生式的直接左递归

### 提取左公因式

通过改写产生式来推迟决定，等读入了足够多的输入，获得足够信息后再做正确的决定。

## 4-3 LL(1)文法

### S_文法（文法中不包含ε产生式）

- 预测分析法的工作过程
  - 从文法的开始符号出发，在每一步推导过程中根据当前句型的最左非终结符A和当前输入符号a，选择正确的A-产生式。为保证分析的正确性，选出的候选式必须是唯一的。

- S_文法（简单的确定性文法）
  - 每个产生式的右部都以终结符开始
  - 同一非终结符的各个候选式的首终结符都不同

### 非终结符的后继符号集

- 可能在某个句型中紧跟在A后边的终结符a的集合，记为FOLLOW(A)
- 如果A是某个句型的最右符号，则将结束符“$”添加到FOLLOW(A)中

### 产生式的可选集

- 产生式A→β的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为SELECT(A→B)
  - SELECT(A→aβ) = { a }
  - SELECT(A→ε)=FOLLOW(A)

- q_文法（不含有右部以非终结符打头的产生式）
  - 每个产生式的右部或为ε，或以终结符开始
  - 具有相同左部的产生式有不相交的可选集

### 串首终结符集

- 串首终结符
  - 串首第一个终结符。简称串首终结符

- 给定一个文法符号串α，α的串首终结符集FIRST(α)被定义为可以从α推导出的所有串首终结符构成的集合。如果α$\Rightarrow^*$ε，那么ε也在FIRST(α)中

### LL(1)文法j          

- 文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式A→α|β满足下面的条件：

  - 不存在终结符a使得α和β都能推导出以a开头的串

  - α和β至多有一个能推导出ε

  - 如果β$\Rightarrow^*$ε，则FIRST(α)∩FOLLOW(A) = Φ；

    如果α$\Rightarrow^*$ε，则FIRST(β)∩FOLLOW(A) = Φ

#  第五章 语义分析































